# 6/1

**学習記録を覚える**<br>
マークダウンは気にしないで自分なりにババっとメモする<br>
覚えのための殴り書きとして使用する<br>
https://qiita.com/Qiita/items/c686397e4a0f4f11683d#note---%E8%A3%9C%E8%B6%B3%E8%AA%AC%E6%98%8E

## GitHubFlowとは
チームで開発する場合、GitHub Flowというブランチ運用方法が使われる。<br>
チーム開発で起こりうる問題点（競合とか）の発生を最小限に抑えるルールに基づいて、GitHubを活用する。

#### GitHub Flowのブランチ
GitHub Flowでは、主に以下の2つのブランチを使用して運用します。

**・main**
本番環境と同じコードを管理するブランチ<br>
開発を行わず、リリースする前の最新の安定版を維持

**・feature**
新しい機能を開発するためのブランチ<br>
mainブランチをもとに新しいブランチを作成して開発

#### ワークフロー
1.ブランチの作成<br>
`git checkout -b`<br>
ブランチ名は実装内容を簡潔に<br>
ルールがあればそれに則る<br>
他のブランチに影響を与えず並行作業できる

2.作成したブランチで実装を進める<br>
`git add .`<br>
変更したファイルを全てステージングへ追加<br>
`git commit`<br>
変更内容をコミットして作業ブランチに記録<br>
`git push`<br>
リモートリポジトリにプシュ<br>
ブランチを分けて安全に作業（回復できる）<br>
commitごとにブランチを切るのが好ましい


3.Pull Requestを作成する<br>
実装内容のレビューをメンバーにお願いする<br>
説明欄に<br>
・実装機能の概要<br>
・詳細<br>
・実装方法<br>
・参考リンクなど<br>
・イメージ図など<br>

4.コードレビューとコメントの対応<br>
レビューするメンバーが、質問、指摘、提案をコメント<br>
実装全体？特定コード？<br>
実装社はレビューに返信したり、修正してcommitとpushで再トライする

5.Pull Requestをマージする<br>
プルリクがレビューののちメンバーに承認された<br>
→ mainブランチに実装内容をマージする<br>
実装内容が統合され共有される<br>
commitとかプルリクの内容も残るから、なにをマージしたんだっけ？ってときは見られる<br>
競合があったら自動でマージされない

6.ブランチを削除する<br>
マージしたら古いブランチは削除する<br>
作業の完了を表し、マージ済みの古いブランチで作業しちゃうことを防ぐ<br>
プルリクやコミットの履歴は消えないから、なんでマージした？ってならない<br>
履歴からブランチを削除することもできるし<br>
プルリクを戻すこともできる？？　修正してプルリクし直すためかな？<br>

> その他
> git rebase
> １つのブランチでcomitが多いと、
> 結局このマージって、総括で何をしたの？ってのがわかりづらくなるのかな？
> コミット履歴を直線的に、わかりやすく保てるんだって
> このZennがわかりやすい気がする
> https://zenn.dev/takamin55/scraps/e9d09441b9c863

> branchを強制削除
> git branch -D 名前
> 
